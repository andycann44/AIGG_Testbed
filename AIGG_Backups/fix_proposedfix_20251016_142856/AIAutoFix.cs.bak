// ASCII only
using System;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using UnityEngine.Networking;

namespace Aim2Pro.AIGG {
  [Serializable] public class ProposedFix {
    public List<string> commands = new List<string>();
    public List<string> macros = new List<string>();
    public List<FieldPair> fieldMap = new List<FieldPair>();
    public string canonical = ""; // optional
  }
  [Serializable] public class FieldPair { public string key = ""; public string value = ""; }

  public static partial class AIAutoFix {
    const string DefaultModel = "gpt-4o-mini";
    const string ChatUrl = "https://api.openai.com/v1/chat/completions";

    static string Esc(string s) => (s ?? "").Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", " ");

    static string BuildPayload(string model, string sys, string user) {
      // Ask for JSON in instructions (no response_format to avoid incompat errors)
      return "{"
           + "\"model\":\"" + Esc(model) + "\","
           + "\"temperature\":0.2,"
           + "\"messages\":["
           + "{\"role\":\"system\",\"content\":\"" + Esc(sys) + "\"},"
           + "{\"role\":\"user\",\"content\":\"" + Esc(user) + "\"}"
           + "]"
           + "}";
    }

    // --- robust helpers ---
    static string ExtractContent(string body) {
      // match JSON string with proper escaping
      var m = Regex.Match(body, "\"content\"\\s*:\\s*\"((?:\\\\.|[^\"\\\\])*)\"", RegexOptions.Singleline);
      if (!m.Success) return null;
      return Regex.Unescape(m.Groups[1].Value);
    }

    static List<string> ParseStringArray(string json, string key) {
      var vals = new List<string>();
      var m = Regex.Match(json, $"\"{key}\"\\s*:\\s*\\[(.*?)\\]", RegexOptions.Singleline);
      if (!m.Success) return vals;
      foreach (Match i in Regex.Matches(m.Groups[1].Value, "\"((?:\\\\.|[^\"\\\\])*)\""))
        vals.Add(Regex.Unescape(i.Groups[1].Value));
      return vals;
    }

    static List<FieldPair> ParseFieldMap(string json) {
      var list = new List<FieldPair>();
      var m = Regex.Match(json, "\"fieldMap\"\\s*:\\s*\\[(.*?)\\]", RegexOptions.Singleline);
      if (!m.Success) return list;
      foreach (Match obj in Regex.Matches(m.Groups[1].Value, "\\{(.*?)\\}", RegexOptions.Singleline)) {
        var k = Regex.Match(obj.Value, "\"key\"\\s*:\\s*\"((?:\\\\.|[^\"\\\\])*)\"").Groups[1].Value;
        var v = Regex.Match(obj.Value, "\"value\"\\s*:\\s*\"((?:\\\\.|[^\"\\\\])*)\"").Groups[1].Value;
        if (!string.IsNullOrEmpty(k) && !string.IsNullOrEmpty(v))
          list.Add(new FieldPair { key = Regex.Unescape(k), value = Regex.Unescape(v) });
      }
      return list;
    }

    static string ParseCanonical(string json) {
      // try as string
      var ms = Regex.Match(json, "\"canonical\"\\s*:\\s*\"((?:\\\\.|[^\"\\\\])*)\"", RegexOptions.Singleline);
      if (ms.Success) return Regex.Unescape(ms.Groups[1].Value);

      // try as object (balance braces)
      var mo = Regex.Match(json, "\"canonical\"\\s*:\\s*\\{", RegexOptions.Singleline);
      if (!mo.Success) return "";
      int start = json.IndexOf('{', mo.Index);
      if (start < 0) return "";
      int depth = 0;
      for (int i = start; i < json.Length; i++) {
        char c = json[i];
        if (c == '{') depth++;
        else if (c == '}') { depth--; if (depth == 0) return json.Substring(start, i - start + 1); }
      }
      return "";
    }

    static string ExtractErr(string body, long code, string fallback) {
      if (string.IsNullOrEmpty(body)) return $"HTTP {code} - {fallback}";
      var m = Regex.Match(body, "\"message\"\\s*:\\s*\"([^\"]+)\"");
      return m.Success ? $"HTTP {code} - {m.Groups[1].Value}" : $"HTTP {code} - {fallback}\n" + body;
    }

    public static ProposedFix Ask(string apiKey, string model, string nl, string normalized, string canonical, List<string> unmatched, List<string> missingCmds, out string error) {
      error = null;
      var result = new ProposedFix();
      if (string.IsNullOrEmpty(apiKey)) { error = "No API key."; return result; }
      if (string.IsNullOrEmpty(model)) model = DefaultModel;

      var sys =
        "You update a game parsing spec. Return ONLY a JSON object with keys: "
        + "\"commands\":[string], \"macros\":[string], "
        + "\"fieldMap\":[{\"key\":\"<phrase>\",\"value\":\"<canonical.path>\"}], "
        + "and optionally \"canonical\":\"<strict canonical JSON>\". "
        + "Action-like new words -> commands (e.g., zigzagRows). Filler words (then,and,over) -> macros. "
        + "Include 'tiles missing' -> 'track.missingTileChance' in fieldMap where relevant.";

      var user =
        "Natural language: " + nl + "\n"
        + "Normalized: " + normalized + "\n"
        + "Current canonical: " + (canonical ?? "") + "\n"
        + "Unknown plan commands: " + string.Join(", ", missingCmds ?? new List<string>()) + "\n"
        + "Unmatched tokens: " + string.Join(", ", unmatched ?? new List<string>()) + "\n"
        + "Return only the JSON object (no commentary).";

      try {
        var payload = BuildPayload(model, sys, user);

        using (var req = new UnityWebRequest(ChatUrl, "POST")) {
          req.uploadHandler = new UploadHandlerRaw(Encoding.UTF8.GetBytes(payload));
          req.downloadHandler = new DownloadHandlerBuffer();
          req.SetRequestHeader("Authorization", "Bearer " + apiKey);
          req.SetRequestHeader("Content-Type", "application/json");
          req.SetRequestHeader("Accept", "application/json");
          var op = req.SendWebRequest();
          while (!op.isDone) {}

#if UNITY_2020_2_OR_NEWER
          bool bad = req.result != UnityWebRequest.Result.Success;
#else
          bool bad = req.isNetworkError || req.isHttpError;
#endif
          var body = req.downloadHandler != null ? (req.downloadHandler.text ?? "") : "";
          if (bad) { error = ExtractErr(body, req.responseCode, req.error); return result; }

          var content = ExtractContent(body);
          if (string.IsNullOrEmpty(content)) { error = "Missing 'content' in response.\n" + body; return result; }

          result.commands = ParseStringArray(content, "commands");
          result.macros   = ParseStringArray(content, "macros");
          result.fieldMap = ParseFieldMap(content);
          result.canonical = ParseCanonical(content);
        }
      } catch (Exception ex) { error = ex.Message; }
      return result;
    }

    public static bool Apply(ProposedFix fix) {
      if (fix == null) return false;
      bool changed = false;
      try {
        if (fix.commands != null && fix.commands.Count > 0)
          changed |= SpecAutoFix.EnsureCommandsExist(fix.commands);
        if (fix.macros != null && fix.macros.Count > 0)
          changed |= SpecAutoFix.EnsureMacrosExist(fix.macros);
        if (fix.fieldMap != null && fix.fieldMap.Count > 0) {
          var dict = new Dictionary<string,string>(StringComparer.OrdinalIgnoreCase);
          foreach (var p in fix.fieldMap)
            if (!string.IsNullOrEmpty(p.key) && !string.IsNullOrEmpty(p.value)) dict[p.key]=p.value;
          changed |= SpecAutoFix.EnsureFieldMapPairs(dict);
        }
      } catch (Exception ex) { Debug.LogWarning("[AIAutoFix] Apply failed: " + ex.Message); }
      return changed;
    }
  }

  public static class AIGGEditorPrefs {
    const string KEY="AIGG_AI_API_KEY", MODEL="AIGG_AI_MODEL", AUTO="AIGG_AI_AUTO_APPLY";
    public static void Save(string apiKey, string model, bool auto) { if (apiKey!=null) EditorPrefs.SetString(KEY,apiKey); if (model!=null) EditorPrefs.SetString(MODEL,model); EditorPrefs.SetBool(AUTO,auto); }
    public static string LoadKey()=>EditorPrefs.GetString(KEY,"");
    public static string LoadModel()=>EditorPrefs.GetString(MODEL,"gpt-4o-mini");
    public static bool LoadAuto()=>EditorPrefs.GetBool(AUTO,false);
  }
}
