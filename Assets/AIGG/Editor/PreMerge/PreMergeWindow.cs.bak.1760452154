#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;
using System;
using System.Text;
using System.Collections.Generic;
using System.Net;
using System.IO;
using System.Text.RegularExpressions;
using Aim2Pro.AIGG;              // MiniJSON, PreMergeRouterAPI
using Aim2Pro.AIGG.PreMerge;     // PreMergeEngine

namespace Aim2Pro.AIGG.PreMerge
{
  public class PreMergeWindow : EditorWindow
  {
    [MenuItem("Window/Aim2Pro/Aigg/Pre-Merge (NL)")]
    public static void Open() {
      var w = GetWindow<PreMergeWindow>("Pre-Merge");
      w.minSize = new Vector2(760, 560);
      w.LoadPrefs();
    }

    string _nl = "";
    string _normalized = "";
    string _issues = "";
    string _missing = "";
    string _canonical = "{ }";
    bool   _blockPreview = false;

    Vector2 sv1, sv2, sv3, sv4;

    // AI settings
    string apiKey = "";
    string model = "gpt-4o-mini";
    bool useAI = true;       // enable OpenAI
    bool aiFirst = false;    // optional: prefer AI

    // AI output folder
    static readonly string AIOutRoot = "Assets/AIGG/AIOut";
    static readonly string SpecRoot  = "Assets/AIGG/Spec";
    void EnsureDir(string p) { var d = System.IO.Path.GetDirectoryName(p); if (!Directory.Exists(d)) Directory.CreateDirectory(d); }
    string Stamp() => DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");

    void LoadPrefs() {
      apiKey  = EditorPrefs.GetString("AIGG_OpenAI_API_Key", "");
      model   = EditorPrefs.GetString("AIGG_OpenAI_Model", "gpt-4o-mini");
      useAI   = EditorPrefs.GetBool("AIGG_OpenAI_Use", true);
      aiFirst = EditorPrefs.GetBool("AIGG_OpenAI_AIFirst", false);
    }
    void SavePrefs() {
      EditorPrefs.SetString("AIGG_OpenAI_API_Key", apiKey ?? "");
      EditorPrefs.SetString("AIGG_OpenAI_Model", model ?? "gpt-4o-mini");
      EditorPrefs.SetBool("AIGG_OpenAI_Use", useAI);
      EditorPrefs.SetBool("AIGG_OpenAI_AIFirst", aiFirst);
    }

    void OnGUI() {
      EditorGUILayout.Space();
      EditorGUILayout.LabelField("Natural Language (input)", EditorStyles.boldLabel);
      sv1 = EditorGUILayout.BeginScrollView(sv1, GUILayout.MinHeight(100));
      _nl = EditorGUILayout.TextArea(_nl, GUILayout.ExpandHeight(true));
      EditorGUILayout.EndScrollView();

      using (new EditorGUILayout.HorizontalScope()) {
        if (GUILayout.Button("Run Pre-Merge")) RunPreMerge();
        if (GUILayout.Button("Local Fix Only")) RunPreMerge(localOnly:true);
        GUILayout.FlexibleSpace();
        using (new EditorGUI.DisabledScope(_blockPreview || !string.IsNullOrEmpty(_missing))) {
          if (GUILayout.Button("Send → Paste & Merge")) {
            PreMergeRouterAPI.Route(_canonical);
          }
        }
      }

      EditorGUILayout.Space();
      EditorGUILayout.LabelField("Normalized", EditorStyles.boldLabel);
      sv2 = EditorGUILayout.BeginScrollView(sv2, GUILayout.MinHeight(80));
      EditorGUILayout.TextArea(_normalized, GUILayout.ExpandHeight(true));
      EditorGUILayout.EndScrollView();

      EditorGUILayout.LabelField("Issues / Missing", EditorStyles.boldLabel);
      sv3 = EditorGUILayout.BeginScrollView(sv3, GUILayout.MinHeight(80));
      EditorGUILayout.TextArea(_issues + (_missing.Length>0 ? ("\nMissing:\n" + _missing) : ""), GUILayout.ExpandHeight(true));
      EditorGUILayout.EndScrollView();

      EditorGUILayout.LabelField("Canonical JSON (preview)", EditorStyles.boldLabel);
      if (_blockPreview || !string.IsNullOrEmpty(_missing)) {
        EditorGUILayout.HelpBox("Canonical JSON hidden until missing items are resolved.", MessageType.Warning);
      }
      sv4 = EditorGUILayout.BeginScrollView(sv4, GUILayout.MinHeight(160));
      EditorGUILayout.TextArea((_blockPreview || !string.IsNullOrEmpty(_missing)) ? "" : _canonical, GUILayout.ExpandHeight(true));
      EditorGUILayout.EndScrollView();

      EditorGUILayout.Space();
      using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox)) {
        EditorGUILayout.LabelField("AI Assist", EditorStyles.boldLabel);
        useAI   = EditorGUILayout.ToggleLeft("Enable OpenAI", useAI);
        aiFirst = EditorGUILayout.ToggleLeft("AI-first (skip local extraction)", aiFirst);
        apiKey  = EditorGUILayout.PasswordField("API Key", apiKey);
        model   = EditorGUILayout.TextField("Model", string.IsNullOrEmpty(model) ? "gpt-4o-mini" : model);
        using (new EditorGUILayout.HorizontalScope()) {
          if (GUILayout.Button("Save Settings", GUILayout.Width(140))) SavePrefs();
          if (GUILayout.Button("Ask AI Now", GUILayout.Width(120))) AskAI();
          if (GUILayout.Button("Reveal AI Output Folder", GUILayout.Width(200))) EditorUtility.RevealInFinder(AIOutRoot);
        }
      }
    }

    void RunPreMerge(bool localOnly=false) {
      _normalized = NormalizeLight(_nl);

      if (useAI && aiFirst && !localOnly) {
        AskAI();
        return;
      }

      var engine = new PreMergeEngine();
      var res = engine.Process(_normalized);

      _canonical   = res.canonicalJson;
      _issues      = JoinBullets(res.issues);
      _missing     = JoinBullets(res.missing);
      _blockPreview = res.missing != null && res.missing.Count > 0;
    }

    string NormalizeLight(string s) {
      if (string.IsNullOrEmpty(s)) return "";
      s = s.Trim();
      s = Regex.Replace(s, "\\s+", " ");
      s = Regex.Replace(s, "\\s*[,;]+\\s*", ", ");
      return s;
    }

    // ---------- AI ----------
    void AskAI() {
      if (!useAI) { ShowNotification(new GUIContent("Enable OpenAI first.")); return; }
      if (string.IsNullOrEmpty(apiKey)) { ShowNotification(new GUIContent("Set API key first.")); return; }

      var system =
        "You are a strict JSON generator for a Unity editor tool called AIGG. " +
        "If multiple spec files must be produced, return an envelope: " +
        "{\"files\":{\"lexicon.json\":{...},\"fieldmap.json\":{...},\"intents.json\":{...},\"schema.json\":{...},\"registry.json\":{...},\"commands.json\":{...},\"macros.json\":{...}}}. " +
        "If only one object is needed, return that single JSON object. " +
        "Do NOT include code fences or comments. Output JSON only.";

      var user =
        "NATURAL LANGUAGE:\n" + _nl + "\n\n" +
        "CURRENT (if any):\n" + _canonical + "\n\n" +
        "TASK: Produce corrected/complete JSON. Include curve steps if NL asks for them. Output JSON only.";

      try {
        var json = OpenAIChat(apiKey, model, system, user);
        if (!string.IsNullOrEmpty(json)) {
          _canonical = json;

          // Re-validate: if NL mentions curve but JSON lacks it, mark missing → hide preview
          var postMissing = ValidateAgainstNL(_nl, _canonical);
          _missing = JoinBullets(postMissing);
          _blockPreview = postMissing.Count > 0;

          var saved = TrySplitAndSaveAIOutput(json, routeFirst: postMissing.Count == 0);
          if (saved > 1 && postMissing.Count == 0) {
            _issues = (_issues + "\n").Trim() + $"Saved {saved} AI files to {AIOutRoot}; first opened in Paste & Merge.";
          }
          Repaint();
          ShowNotification(new GUIContent("AI completed."));
        }
      } catch (Exception ex) {
        ShowNotification(new GUIContent("AI error: " + ex.Message));
      }
    }

    // If NL implies curve but canonical lacks it, return a "curve missing"
    List<string> ValidateAgainstNL(string nl, string canonicalJson) {
      var list = new List<string>();
      bool mentionsCurve =
        Regex.IsMatch(nl, "\\b(left|right)\\b.*\\b(\\d+)\\s*(?:deg|degree|degrees)\\b.*\\b(\\d+)\\s*rows?\\b", RegexOptions.IgnoreCase) ||
        Regex.IsMatch(nl, "\\b(\\d+)\\s*(?:deg|degree|degrees)\\b.*\\b(left|right)\\b.*\\b(\\d+)\\s*rows?\\b", RegexOptions.IgnoreCase);

      if (string.IsNullOrWhiteSpace(canonicalJson)) { list.Add("no canonical json"); return list; }

      object obj;
      if (!MiniJSON.TryDeserialize(canonicalJson, out obj) || !(obj is Dictionary<string,object> d)) {
        list.Add("invalid canonical json"); return list;
      }

      bool hasCurve = false;
      if (d.TryGetValue("plan", out var p) && p is List<object> arr) {
        foreach (var o in arr) {
          var dd = o as Dictionary<string,object>;
          if (dd!=null && dd.TryGetValue("action", out var a)
              && string.Equals(a?.ToString(), "curveRowsOver", StringComparison.OrdinalIgnoreCase)) {
            hasCurve = true; break;
          }
        }
      }
      if (mentionsCurve && !hasCurve) list.Add("curve step (plan[].action='curveRowsOver')");

      return list;
    }

    string JoinBullets(List<string> xs){
      if (xs==null || xs.Count==0) return "";
      var sb=new StringBuilder();
      foreach (var x in xs) sb.AppendLine("• " + x);
      return sb.ToString().Trim();
    }

    // --- split/save envelope & optionally route the first file ---
    int TrySplitAndSaveAIOutput(string text, bool routeFirst = true)
    {
      if (string.IsNullOrWhiteSpace(text)) return 0;

      var rawPath = System.IO.Path.Combine(AIOutRoot, "raw", $"ai_{Stamp()}.json");
      EnsureDir(rawPath);
      File.WriteAllText(rawPath, text, Encoding.UTF8);

      try {
        object root;
        if (MiniJSON.TryDeserialize(text, out root) && root is Dictionary<string,object> d)
        {
          if (d.TryGetValue("files", out var filesObj) && filesObj is Dictionary<string,object> files && files.Count>0)
          {
            int saved=0;
            string firstWrapper=null;
            foreach (var kv in files)
            {
              var keyLower = (kv.Key ?? "").ToString().ToLowerInvariant();
              string target =
                keyLower.Contains("lexicon")  ? "Lexicon"  :
                keyLower.Contains("fieldmap") ? "Fieldmap" :
                keyLower.Contains("intents")  ? "Intents"  :
                keyLower.Contains("schema")   ? "Schema"   :
                keyLower.Contains("registry") ? "Registry" :
                keyLower.Contains("commands") ? "Commands" :
                keyLower.Contains("macros")   ? "Macros"   : "Schema";

              var folder = System.IO.Path.Combine(AIOutRoot, target);
              Directory.CreateDirectory(folder);
              var path = System.IO.Path.Combine(folder, $"{target}_{Stamp()}.json");
              File.WriteAllText(path, MiniJSON.Serialize(kv.Value, pretty:true), Encoding.UTF8);
              saved++;

              if (firstWrapper == null) {
                var wrap = new Dictionary<string,object>{{"target",target},{"content",kv.Value}};
                firstWrapper = MiniJSON.Serialize(wrap, pretty:true);
              }
            }
            if (routeFirst && firstWrapper != null) PreMergeRouterAPI.Route(firstWrapper);
            return saved;
          }
        }
      } catch {}

      // single json -> archive under Canonical
      var single = System.IO.Path.Combine(AIOutRoot, "Canonical", $"canonical_{Stamp()}.json");
      EnsureDir(single);
      File.WriteAllText(single, text, Encoding.UTF8);
      return 1;
    }

    // --- minimal OpenAI client ---
    string OpenAIChat(string key, string model, string system, string user) {
      var url = "https://api.openai.com/v1/chat/completions";
      var req = (HttpWebRequest)WebRequest.Create(url);
      req.Method = "POST";
      req.ContentType = "application/json";
      req.Headers["Authorization"] = "Bearer " + key;
      req.Timeout = 30000;

      var payload = "{"
        + "\"model\":\"" + Escape(model) + "\","
        + "\"temperature\":0,"
        + "\"messages\":["
        + "{\"role\":\"system\",\"content\":\"" + Escape(system) + "\"},"
        + "{\"role\":\"user\",\"content\":\"" + Escape(user) + "\"}"
        + "]"
        + "}";

      var bytes = Encoding.UTF8.GetBytes(payload);
      using (var stream = req.GetRequestStream()) stream.Write(bytes, 0, bytes.Length);

      string body = null;
      using (var resp = (HttpWebResponse)req.GetResponse())
      using (var rs = resp.GetResponseStream())
      using (var sr = new StreamReader(rs)) body = sr.ReadToEnd();

      object root;
      if (MiniJSON.TryDeserialize(body, out root) && root is Dictionary<string, object> d
          && d.TryGetValue("choices", out var ch) && ch is List<object> arr && arr.Count>0) {
        var c0 = arr[0] as Dictionary<string, object>;
        if (c0 != null && c0.TryGetValue("message", out var msg) && msg is Dictionary<string, object> md
            && md.TryGetValue("content", out var content)) {
          var text = content?.ToString() ?? "";
          var m = Regex.Match(text, "```(?:json)?\\s*([\\s\\S]*?)\\s*```", RegexOptions.IgnoreCase);
          if (m.Success) text = m.Groups[1].Value;
          return text.Trim();
        }
      }
      throw new Exception("Unexpected AI response.");
    }

    string Escape(string s) {
      if (string.IsNullOrEmpty(s)) return "";
      var sb = new StringBuilder();
      foreach (var c in s) {
        if (c == '\\') sb.Append("\\\\");
        else if (c == '\"') sb.Append("\\\"");
        else if (c == '\n') sb.Append("\\n");
        else if (c == '\r') sb.Append("\\r");
        else if (c == '\t') sb.Append("\\t");
        else if (c < ' ') sb.Append("\\u").Append(((int)c).ToString("x4"));
        else sb.Append(c);
      }
      return sb.ToString();
    }
  }
}
#endif
